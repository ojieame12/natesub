/**
 * Admin System Controller
 *
 * System health, monitoring, and operational routes.
 * Includes: health, webhooks, transfers, reconciliation, dashboard stats,
 * activity feed, system logs, reminders, emails, invoices.
 */

import { Hono } from 'hono'
import { z } from 'zod'
import { Prisma } from '@prisma/client'
import dlq from '../../services/dlq.js'
import { db } from '../../db/client.js'
import { stripe } from '../../services/stripe.js'
import { getStuckTransfers, getTransferStats } from '../../jobs/transfers.js'
import { getMissingTransactions, reconcilePaystackTransactions } from '../../jobs/reconciliation.js'
import { checkEmailHealth, sendTestEmail, _sendEmail } from '../../services/email.js'
import { isSmsEnabled, sendVerificationSms } from '../../services/sms.js'
import { env } from '../../config/env.js'
import { handleInvoicePaid } from '../webhooks/stripe/invoice.js'
import { todayStart, thisMonthStart, lastNDays, BUSINESS_TIMEZONE } from '../../utils/timezone.js'
import { adminSensitiveRateLimit } from '../../middleware/rateLimit.js'
import { getSessionToken, isAdminRole, requireRole, logAdminAction, requireFreshSession } from '../../middleware/adminAuth.js'
import { validateSession } from '../../services/auth.js'

import { redis } from '../../db/redis.js'
import { cached, CACHE_TTL, adminDashboardKey } from '../../utils/cache.js'
import { isStripeCrossBorder } from '../../utils/countryConfig.js'

const system = new Hono()

import { randomBytes } from 'crypto'

// Redis key for distributed reconciliation lock
const RECONCILIATION_LOCK_KEY = 'admin:reconciliation:lock'
const RECONCILIATION_LOCK_TTL = 300 // 5 minutes max lock duration

// Redis key prefix for reconciliation autoFix confirmation tokens
const RECONCILIATION_TOKEN_PREFIX = 'admin:reconciliation:token:'
const RECONCILIATION_TOKEN_TTL = 300 // 5 minutes

// Acquire distributed lock for reconciliation
async function acquireReconciliationLock(): Promise<boolean> {
  // SET NX with expiry - atomic operation
  const result = await redis.set(RECONCILIATION_LOCK_KEY, Date.now().toString(), 'EX', RECONCILIATION_LOCK_TTL, 'NX')
  return result === 'OK'
}

// Release distributed lock
async function releaseReconciliationLock(): Promise<void> {
  await redis.del(RECONCILIATION_LOCK_KEY)
}

// Generate a one-time confirmation token for autoFix operations
async function generateReconciliationToken(data: {
  periodHours: number
  discrepancies: number
  adminUserId: string
}): Promise<string> {
  const token = randomBytes(16).toString('hex')
  const key = `${RECONCILIATION_TOKEN_PREFIX}${token}`
  await redis.setex(key, RECONCILIATION_TOKEN_TTL, JSON.stringify(data))
  return token
}

// Validate and consume a confirmation token (single use)
async function validateReconciliationToken(token: string, adminUserId: string): Promise<{
  valid: boolean
  periodHours?: number
  discrepancies?: number
  error?: string
}> {
  const key = `${RECONCILIATION_TOKEN_PREFIX}${token}`
  const data = await redis.get(key)

  if (!data) {
    return { valid: false, error: 'Invalid or expired confirmation token. Run preview again.' }
  }

  const parsed = JSON.parse(data) as { periodHours: number; discrepancies: number; adminUserId: string }

  // Token must be used by the same admin who generated it
  if (parsed.adminUserId !== adminUserId) {
    return { valid: false, error: 'Token was generated by a different admin. Run preview again.' }
  }

  // Consume the token (single use)
  await redis.del(key)

  return {
    valid: true,
    periodHours: parsed.periodHours,
    discrepancies: parsed.discrepancies,
  }
}

// ============================================
// ADMIN STATUS CHECK
// ============================================

/**
 * GET /admin/me
 * Check if current user is an admin
 */
system.get('/me', async (c) => {
  try {
    const sessionToken = getSessionToken(c)
    if (!sessionToken) {
      return c.json({ isAdmin: false })
    }

    const session = await validateSession(sessionToken)
    if (!session) {
      return c.json({ isAdmin: false })
    }

    const user = await db.user.findUnique({
      where: { id: session.userId },
      select: { email: true, role: true },
    })

    if (user && isAdminRole(user.role)) {
      return c.json({ isAdmin: true, email: user.email, role: user.role })
    }

    return c.json({ isAdmin: false })
  } catch (err) {
    console.error('[admin/me] Error:', err)
    return c.json({ isAdmin: false })
  }
})

// ============================================
// HEALTH & DIAGNOSTICS
// ============================================

/**
 * GET /admin/health
 * System health check
 */
system.get('/health', async (c) => {
  try {
    await db.$queryRaw`SELECT 1`
    const emailHealth = await checkEmailHealth()

    return c.json({
      status: emailHealth.healthy ? 'healthy' : 'degraded',
      timestamp: new Date().toISOString(),
      database: 'connected',
      email: emailHealth.healthy ? 'connected' : 'error',
      emailError: emailHealth.error || undefined,
    })
  } catch (error) {
    return c.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      database: 'disconnected',
      error: error instanceof Error ? error.message : 'Unknown error',
    }, 503)
  }
})

/**
 * GET /admin/email/health
 * Email service health check
 */
system.get('/email/health', async (c) => {
  const health = await checkEmailHealth()
  return c.json({
    healthy: health.healthy,
    error: health.error,
    timestamp: new Date().toISOString(),
  }, health.healthy ? 200 : 503)
})

/**
 * POST /admin/email/test
 * Send a test email
 */
system.post('/email/test', async (c) => {
  const body = await c.req.json().catch(() => ({}))
  const to = body.to

  if (!to || typeof to !== 'string' || !to.includes('@')) {
    return c.json({ error: 'Valid email address required in "to" field' }, 400)
  }

  const result = await sendTestEmail(to)

  return c.json({
    success: result.success,
    messageId: result.messageId,
    attempts: result.attempts,
    error: result.error,
  }, result.success ? 200 : 500)
})

// ============================================
// SMS HEALTH & TESTING
// ============================================

/**
 * GET /admin/sms/health
 * SMS service health check
 */
system.get('/sms/health', async (c) => {
  const enabled = isSmsEnabled()
  const configured = !!(env.BIRD_ACCESS_KEY && env.BIRD_WORKSPACE_ID && env.BIRD_CHANNEL_ID)

  return c.json({
    enabled: env.ENABLE_SMS,
    configured,
    ready: enabled,
    config: {
      hasAccessKey: !!env.BIRD_ACCESS_KEY,
      hasWorkspaceId: !!env.BIRD_WORKSPACE_ID,
      hasChannelId: !!env.BIRD_CHANNEL_ID,
      senderId: env.BIRD_SENDER_ID || 'NatePay',
    },
    timestamp: new Date().toISOString(),
  })
})

/**
 * POST /admin/sms/test
 * Send a test SMS
 */
system.post('/sms/test', async (c) => {
  const body = await c.req.json().catch(() => ({}))
  const to = body.to

  if (!to || typeof to !== 'string') {
    return c.json({ error: 'Phone number required in "to" field (E.164 format, e.g., +2348012345678)' }, 400)
  }

  // Basic E.164 validation
  if (!to.startsWith('+') || to.length < 10) {
    return c.json({ error: 'Phone must be in E.164 format (e.g., +2348012345678)' }, 400)
  }

  if (!isSmsEnabled()) {
    // Don't reveal specific configuration details - just indicate SMS is unavailable
    return c.json({
      error: 'SMS is not enabled. Contact system administrator.',
      enabled: false,
    }, 400)
  }

  try {
    // Send a test verification code
    const testCode = '123456'
    await sendVerificationSms(to, testCode)

    await logAdminAction(c, 'sms_test_sent', { to: to.slice(0, 6) + '****' })

    return c.json({
      success: true,
      message: `Test SMS sent to ${to.slice(0, 6)}****`,
    })
  } catch (error: any) {
    console.error('[admin/sms/test] Error:', error)
    return c.json({
      success: false,
      error: error.message || 'Failed to send SMS',
    }, 500)
  }
})

/**
 * GET /admin/metrics
 * Basic platform metrics
 */
system.get('/metrics', async (c) => {
  const [
    totalUsers,
    totalProfiles,
    activeSubscriptions,
    totalRevenue,
  ] = await Promise.all([
    db.user.count(),
    db.profile.count(),
    db.subscription.count({ where: { status: 'active' } }),
    db.subscription.aggregate({
      where: { status: 'active' },
      _sum: { amount: true },
    }),
  ])

  return c.json({
    users: totalUsers,
    profiles: totalProfiles,
    activeSubscriptions,
    monthlyRecurringRevenue: totalRevenue._sum.amount || 0,
  })
})

/**
 * GET /admin/dashboard
 * Dashboard stats (cached for 60 seconds)
 *
 * DATA SOURCE NOTE:
 * This endpoint uses DB aggregates (payments table) for revenue metrics.
 * The admin Stripe tab uses live Stripe API calls (stripe.balance.retrieve).
 * This creates a data freshness gap:
 * - DB data lags behind Stripe by webhook processing time (typically <1min)
 * - Cached for 60s, so could be up to ~2min behind live Stripe
 *
 * The freshness metadata helps surface this gap to admins.
 * Future improvement: Consider adding live Stripe balance to this endpoint
 * for full consistency, or clearly label DB-sourced vs live data in UI.
 */
system.get('/dashboard', async (c) => {
  const result = await cached(
    adminDashboardKey('overview'),
    CACHE_TTL.SHORT, // 60 seconds
    async () => {
      const startOfDay = todayStart()
      const startOfMonth = thisMonthStart()

      const [
        totalUsers,
        newUsersToday,
        newUsersThisMonth,
        activeSubscriptions,
        // Group by currency for accurate per-currency revenue
        totalRevenueByCurrency,
        thisMonthRevenueByCurrency,
        // Legacy payments (grossCents is null, use amountCents)
        legacyTotalByCurrency,
        legacyThisMonthByCurrency,
        // Stored USD reporting amounts (accurate historical totals)
        reportingTotals,
        reportingThisMonth,
        // Count payments with estimated reporting (for UI indicator)
        estimatedCount,
        disputedPayments,
        failedPaymentsToday,
        lastPayment,
        lastProcessedWebhook,
        fxDataByCurrency,
        refundsTotals,
        disputesTotals,
        missingFxByCurrency
      ] = await Promise.all([
        db.user.count({ where: { deletedAt: null } }),
        db.user.count({ where: { createdAt: { gte: startOfDay }, deletedAt: null } }),
        db.user.count({ where: { createdAt: { gte: startOfMonth }, deletedAt: null } }),
        db.subscription.count({ where: { status: 'active' } }),
        // Group by currency for accurate revenue reporting (new schema: grossCents)
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] } },
          _sum: { feeCents: true, grossCents: true },
          _count: true
        }),
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, occurredAt: { gte: startOfMonth } },
          _sum: { feeCents: true, grossCents: true },
          _count: true
        }),
        // Legacy payments: amountCents when grossCents is null
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, grossCents: null },
          _sum: { amountCents: true },
          _count: true
        }),
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, occurredAt: { gte: startOfMonth }, grossCents: null },
          _sum: { amountCents: true },
          _count: true
        }),
        // Stored USD reporting amounts (use these for accurate historical totals)
        db.payment.aggregate({
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, reportingCurrency: 'USD' },
          _sum: { reportingFeeCents: true, reportingGrossCents: true, reportingNetCents: true },
        }),
        db.payment.aggregate({
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, occurredAt: { gte: startOfMonth }, reportingCurrency: 'USD' },
          _sum: { reportingFeeCents: true, reportingGrossCents: true, reportingNetCents: true },
        }),
        // Count payments with estimated reporting data
        db.payment.count({
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, reportingIsEstimated: true }
        }),
        db.payment.count({ where: { status: 'disputed' } }),
        db.payment.count({ where: { status: 'failed', occurredAt: { gte: startOfDay } } }),
        // Freshness: last payment
        db.payment.findFirst({
          where: { status: 'succeeded' },
          orderBy: { occurredAt: 'desc' },
          select: { occurredAt: true }
        }),
        // Freshness: last processed webhook
        db.webhookEvent.findFirst({
          where: { status: 'processed' },
          orderBy: { processedAt: 'desc' },
          select: { processedAt: true, provider: true, eventType: true }
        }),
        // Weighted FX rate data per currency: sum grossCents and reportingGrossCents for weighted avg
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, reportingGrossCents: { not: null } },
          _sum: { grossCents: true, reportingGrossCents: true },
          _max: { reportingRateTimestamp: true },
          _count: true,
        }),
        // Refunds total (for annotation)
        db.payment.aggregate({
          where: { status: 'refunded', type: { in: ['recurring', 'one_time'] } },
          _sum: { reportingGrossCents: true },
          _count: true,
        }),
        // Chargebacks/disputes total
        db.payment.aggregate({
          where: { status: 'disputed', type: { in: ['recurring', 'one_time'] } },
          _sum: { reportingGrossCents: true },
          _count: true,
        }),
        // Payments missing FX data (for "—" display)
        db.payment.groupBy({
          by: ['currency'],
          where: { status: 'succeeded', type: { in: ['recurring', 'one_time'] }, reportingGrossCents: null },
          _count: true,
        })
      ])

      // Build legacy amount maps (for payments where grossCents is null)
      const legacyTotalMap = new Map(legacyTotalByCurrency.map(c => [c.currency, c._sum.amountCents || 0]))
      const legacyThisMonthMap = new Map(legacyThisMonthByCurrency.map(c => [c.currency, c._sum.amountCents || 0]))

      // Build weighted FX rate map: rate = SUM(grossCents) / SUM(reportingGrossCents)
      // This gives the effective exchange rate weighted by transaction size
      const fxRateMap = new Map<string, { weightedRate: number | null; latestRateAt: Date | null; usdCents: number }>(
        fxDataByCurrency.map(c => {
          const gross = c._sum.grossCents || 0
          const usd = c._sum.reportingGrossCents || 0
          // Weighted rate: local cents per USD cent
          const weightedRate = usd > 0 ? gross / usd : null
          return [c.currency, {
            weightedRate,
            latestRateAt: c._max.reportingRateTimestamp || null,
            usdCents: usd
          }]
        })
      )

      // Map of currencies missing FX data (show "—" instead of fake rate)
      const missingFxMap = new Map(missingFxByCurrency.map(c => [c.currency, c._count]))

      // Build per-currency breakdown with FX metadata
      type CurrencyData = {
        feeCents: number
        volumeCents: number
        paymentCount: number
        // FX data
        weightedExchangeRate: number | null
        latestRateAt: string | null
        usdEquivCents: number | null
        missingFxCount: number
      }
      const byCurrency: Record<string, CurrencyData> = {}
      const thisMonthByCurrency: Record<string, CurrencyData> = {}

      for (const c of totalRevenueByCurrency) {
        const legacyVolume = legacyTotalMap.get(c.currency) || 0
        const fxData = fxRateMap.get(c.currency)
        byCurrency[c.currency] = {
          feeCents: c._sum.feeCents || 0,
          volumeCents: (c._sum.grossCents || 0) + legacyVolume,
          paymentCount: c._count,
          weightedExchangeRate: fxData?.weightedRate || null,
          latestRateAt: fxData?.latestRateAt?.toISOString() || null,
          usdEquivCents: fxData?.usdCents || null,
          missingFxCount: missingFxMap.get(c.currency) || 0
        }
      }

      for (const c of thisMonthRevenueByCurrency) {
        const legacyVolume = legacyThisMonthMap.get(c.currency) || 0
        const fxData = fxRateMap.get(c.currency)
        thisMonthByCurrency[c.currency] = {
          feeCents: c._sum.feeCents || 0,
          volumeCents: (c._sum.grossCents || 0) + legacyVolume,
          paymentCount: c._count,
          weightedExchangeRate: fxData?.weightedRate || null,
          latestRateAt: fxData?.latestRateAt?.toISOString() || null,
          usdEquivCents: fxData?.usdCents || null,
          missingFxCount: missingFxMap.get(c.currency) || 0
        }
      }

      const currencies = Object.keys(byCurrency)
      const thisMonthCurrencies = Object.keys(thisMonthByCurrency)
      const isMultiCurrency = currencies.length > 1
      const isThisMonthMultiCurrency = thisMonthCurrencies.length > 1

      // Calculate totals (for backward compatibility - but flag if mixed)
      const totalCents = Object.values(byCurrency).reduce((sum, c) => sum + c.feeCents, 0)
      const totalVolumeCents = Object.values(byCurrency).reduce((sum, c) => sum + c.volumeCents, 0)
      const paymentCount = Object.values(byCurrency).reduce((sum, c) => sum + c.paymentCount, 0)
      const thisMonthCents = Object.values(thisMonthByCurrency).reduce((sum, c) => sum + c.feeCents, 0)
      const thisMonthVolumeCents = Object.values(thisMonthByCurrency).reduce((sum, c) => sum + c.volumeCents, 0)
      const thisMonthPaymentCount = Object.values(thisMonthByCurrency).reduce((sum, c) => sum + c.paymentCount, 0)

      // USD equivalent totals from stored reporting amounts
      // These are calculated at payment time using the FX rate at that moment
      // Much more accurate than live conversion for historical totals
      const totalFeesUsdCents = reportingTotals._sum.reportingFeeCents || 0
      const totalVolumeUsdCents = reportingTotals._sum.reportingGrossCents || 0
      const thisMonthFeesUsdCents = reportingThisMonth._sum.reportingFeeCents || 0
      const thisMonthVolumeUsdCents = reportingThisMonth._sum.reportingGrossCents || 0

      // Find the most recent rate timestamp across all currencies (for "rates as of X")
      const latestRateDate = Object.values(byCurrency)
        .map(c => c.latestRateAt)
        .filter((d): d is string => d !== null)
        .sort()
        .pop() || null

      // Refunds and disputes (for admin reconciliation)
      const refundsUsdCents = refundsTotals._sum.reportingGrossCents || 0
      const refundsCount = refundsTotals._count || 0
      const disputesUsdCents = disputesTotals._sum.reportingGrossCents || 0
      const disputesCount = disputesTotals._count || 0

      return {
        users: { total: totalUsers, newToday: newUsersToday, newThisMonth: newUsersThisMonth },
        subscriptions: { active: activeSubscriptions },
        revenue: {
          // Per-currency breakdown (accurate)
          byCurrency,
          thisMonthByCurrency,
          // Currency metadata
          currencies,
          thisMonthCurrencies,
          isMultiCurrency,
          isThisMonthMultiCurrency,
          // Totals (backward compatibility - WARNING: mixed currencies if isMultiCurrency=true)
          totalCents,
          thisMonthCents,
          totalVolumeCents,
          thisMonthVolumeCents,
          paymentCount,
          thisMonthPaymentCount,
          // USD equivalent totals (from stored reporting amounts - captured at payment time)
          usdEquivalent: {
            totalFeesUsdCents,
            totalVolumeUsdCents,
            thisMonthFeesUsdCents,
            thisMonthVolumeUsdCents,
            // Flag if any payments have estimated rates (backfilled with current rate)
            hasEstimatedRates: estimatedCount > 0,
            estimatedPaymentCount: estimatedCount,
            // Latest rate date for "rates as of X" subtext
            latestRateAt: latestRateDate,
          },
          // Adjustments (for admin reconciliation annotations)
          adjustments: {
            refundsUsdCents,
            refundsCount,
            disputesUsdCents,
            disputesCount,
            totalAdjustmentsUsdCents: refundsUsdCents + disputesUsdCents,
          }
        },
        flags: { disputedPayments, failedPaymentsToday },
        freshness: {
          businessTimezone: BUSINESS_TIMEZONE,
          lastPaymentAt: lastPayment?.occurredAt?.toISOString() || null,
          lastWebhookProcessedAt: lastProcessedWebhook?.processedAt?.toISOString() || null,
          lastWebhookProvider: lastProcessedWebhook?.provider || null
        }
      }
    }
  )

  return c.json(result)
})

// ============================================
// WEBHOOK MONITORING
// ============================================

/**
 * GET /admin/webhooks/stats
 * Webhook processing status
 */
system.get('/webhooks/stats', async (c) => {
  const [failedCounts, deadLetterCount, recentProcessed] = await Promise.all([
    dlq.getFailedWebhookCounts(),
    db.webhookEvent.count({ where: { status: 'dead_letter' } }),
    db.webhookEvent.count({
      where: {
        status: 'processed',
        processedAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) },
      },
    }),
  ])

  return c.json({
    failed: failedCounts,
    deadLetter: deadLetterCount,
    processedLast24h: recentProcessed,
  })
})

/**
 * GET /admin/webhooks/failed
 * List failed webhooks ready for retry
 */
system.get('/webhooks/failed', async (c) => {
  const rawEvents = await dlq.getFailedWebhooksForRetry()
  const events = rawEvents.map(event => ({
    id: event.id,
    provider: event.provider,
    type: event.eventType,
    status: 'failed',
    retryCount: event.retryCount,
    createdAt: event.createdAt.toISOString(),
    error: event.error,
  }))
  return c.json({ events })
})

/**
 * GET /admin/webhooks/dead-letter
 * List webhooks that exceeded max retries
 */
system.get('/webhooks/dead-letter', async (c) => {
  const events = await dlq.getDeadLetterWebhooks()
  return c.json({ events })
})

/**
 * GET /admin/webhooks/all
 * List ALL webhook events
 */
system.get('/webhooks/all', async (c) => {
  const query = z.object({
    limit: z.coerce.number().min(1).max(200).default(50),
    provider: z.enum(['stripe', 'paystack', 'all']).default('all'),
    status: z.enum(['received', 'processing', 'processed', 'failed', 'skipped', 'dead_letter', 'all']).default('all'),
  }).parse(c.req.query())

  const where: any = {}
  if (query.provider !== 'all') where.provider = query.provider
  if (query.status !== 'all') where.status = query.status

  const events = await db.webhookEvent.findMany({
    where,
    orderBy: { createdAt: 'desc' },
    take: query.limit,
  })

  return c.json({
    events: events.map(e => ({
      id: e.id,
      provider: e.provider,
      eventId: e.eventId,
      type: e.eventType,
      status: e.status,
      error: e.error,
      retryCount: e.retryCount,
      processingTimeMs: e.processingTimeMs,
      createdAt: e.createdAt,
      processedAt: e.processedAt,
    })),
    total: events.length,
  })
})

/**
 * POST /admin/webhooks/:id/retry
 * Manually retry a specific webhook
 */
system.post('/webhooks/:id/retry', adminSensitiveRateLimit, async (c) => {
  const { id } = c.req.param()
  const result = await dlq.retryWebhook(id)

  if (!result.success) {
    return c.json({ error: result.error }, 400)
  }

  await logAdminAction(c, 'webhook_retry', { webhookId: id })

  return c.json({ success: true, message: 'Webhook queued for retry' })
})

// ============================================
// STRIPE SYNC
// ============================================

/**
 * POST /admin/sync/stripe-invoice
 * Manually sync a Stripe invoice to local database
 */
system.post('/sync/stripe-invoice', adminSensitiveRateLimit, async (c) => {
  const body = z.object({
    invoiceId: z.string().startsWith('in_'),
  }).parse(await c.req.json())

  try {
    const invoice = await stripe.invoices.retrieve(body.invoiceId)

    if (invoice.status !== 'paid') {
      return c.json({ error: `Invoice status is ${invoice.status}, not paid` }, 400)
    }

    const invoiceAny = invoice as any
    const existing = await db.payment.findFirst({
      where: {
        OR: [
          { stripePaymentIntentId: invoiceAny.payment_intent as string },
          { stripeChargeId: invoiceAny.charge as string },
        ]
      }
    })

    if (existing) {
      return c.json({ error: 'Payment already exists', paymentId: existing.id }, 400)
    }

    const fakeEvent = {
      id: `manual_sync_${Date.now()}`,
      type: 'invoice.paid',
      data: { object: invoice },
    }

    await handleInvoicePaid(fakeEvent as any)

    await logAdminAction(c, 'sync_stripe_invoice', {
      invoiceId: body.invoiceId,
      amount: invoice.amount_paid,
      currency: invoice.currency,
    })

    return c.json({ success: true, message: `Synced invoice ${body.invoiceId}` })
  } catch (err: any) {
    console.error('[admin] Sync invoice failed:', err)
    return c.json({ error: err.message }, 500)
  }
})

/**
 * GET /admin/sync/stripe-missing
 * Find Stripe invoices that are missing from local database
 * Uses batch lookup to avoid N+1 queries
 */
system.get('/sync/stripe-missing', async (c) => {
  const query = z.object({
    limit: z.coerce.number().min(1).max(200).default(20),
  }).parse(c.req.query())

  try {
    const invoices = await stripe.invoices.list({
      status: 'paid',
      limit: query.limit,
      expand: ['data.subscription'],
    })

    // Collect all payment intents and charge IDs for batch lookup
    const paymentIntentIds: string[] = []
    const chargeIds: string[] = []

    for (const invoice of invoices.data) {
      const inv = invoice as any
      if (inv.payment_intent) paymentIntentIds.push(inv.payment_intent as string)
      if (inv.charge) chargeIds.push(inv.charge as string)
    }

    // Single batch query instead of N queries
    const existingPayments = await db.payment.findMany({
      where: {
        OR: [
          { stripePaymentIntentId: { in: paymentIntentIds } },
          { stripeChargeId: { in: chargeIds } },
        ].filter(ids => ids.stripePaymentIntentId?.in?.length || ids.stripeChargeId?.in?.length)
      },
      select: {
        stripePaymentIntentId: true,
        stripeChargeId: true,
      }
    })

    // Create lookup sets for O(1) existence checks
    const existingPaymentIntents = new Set(existingPayments.map(p => p.stripePaymentIntentId).filter(Boolean))
    const existingCharges = new Set(existingPayments.map(p => p.stripeChargeId).filter(Boolean))

    const missing: any[] = []

    for (const invoice of invoices.data) {
      const inv = invoice as any
      const hasPayment = existingPaymentIntents.has(inv.payment_intent as string) ||
                         existingCharges.has(inv.charge as string)

      if (!hasPayment) {
        missing.push({
          invoiceId: invoice.id,
          amount: invoice.amount_paid,
          currency: invoice.currency,
          customerEmail: invoice.customer_email,
          created: new Date(invoice.created * 1000),
          subscriptionId: typeof inv.subscription === 'string'
            ? inv.subscription
            : inv.subscription?.id,
        })
      }
    }

    return c.json({
      missing,
      total: missing.length,
      checked: invoices.data.length,
    })
  } catch (err: any) {
    console.error('[admin] Check missing invoices failed:', err)
    return c.json({ error: err.message }, 500)
  }
})

// ============================================
// TRANSFER MONITORING
// ============================================

/**
 * GET /admin/transfers/stats
 * Transfer statistics
 */
system.get('/transfers/stats', async (c) => {
  const stats = await getTransferStats()
  return c.json(stats)
})

/**
 * GET /admin/transfers/stuck
 * List transfers stuck in otp_pending status
 */
system.get('/transfers/stuck', async (c) => {
  const minAgeHours = c.req.query('minAge') ? parseInt(c.req.query('minAge')!) : undefined
  const transfers = await getStuckTransfers(minAgeHours)

  return c.json({
    count: transfers.length,
    transfers,
    warning: transfers.length > 0
      ? 'These transfers require OTP finalization. Either disable OTP in Paystack dashboard or manually approve.'
      : null,
  })
})

/**
 * GET /admin/transfers/all-pending
 * List all pending transfers
 */
system.get('/transfers/all-pending', async (c) => {
  const transfers = await db.payment.findMany({
    where: {
      type: 'payout',
      status: { in: ['pending', 'otp_pending'] },
    },
    include: {
      subscription: {
        include: {
          creator: {
            select: {
              email: true,
              profile: {
                select: { displayName: true, username: true },
              },
            },
          },
        },
      },
    },
    orderBy: { createdAt: 'asc' },
    take: 100,
  })

  return c.json({
    count: transfers.length,
    transfers: transfers.map(t => ({
      id: t.id,
      creatorId: t.creatorId,
      creatorName: t.subscription?.creator?.profile?.displayName
        || t.subscription?.creator?.profile?.username
        || 'Unknown',
      amountCents: t.amountCents,
      netCents: t.netCents,
      currency: t.currency,
      status: t.status,
      transferCode: t.paystackTransferCode,
      createdAt: t.createdAt,
    })),
  })
})

// ============================================
// RECONCILIATION
// ============================================

/**
 * GET /admin/reconciliation/missing
 * List Paystack transactions missing from DB
 */
system.get('/reconciliation/missing', async (c) => {
  const periodHours = c.req.query('hours') ? parseInt(c.req.query('hours')!) : 48
  const result = await getMissingTransactions(periodHours)

  return c.json({
    periodHours,
    ...result,
    warning: result.count > 0
      ? 'These transactions succeeded in Paystack but have no record in your database. Possible webhook failure - creators may not have been paid.'
      : null,
  })
})

/**
 * POST /admin/reconciliation/preview
 * Preview what reconciliation would fix and get a confirmation token
 * The token is required to run autoFix=true
 * Requires: super_admin
 */
system.post('/reconciliation/preview', adminSensitiveRateLimit, requireRole('super_admin'), async (c) => {
  const body = await c.req.json().catch(() => ({}))
  const periodHours = body.periodHours || 48

  const adminUserId = c.get('adminUserId')
  if (!adminUserId) {
    return c.json({ error: 'Session authentication required for preview' }, 401)
  }

  // Get missing transactions without fixing
  const preview = await getMissingTransactions(periodHours)

  // Generate confirmation token if there are discrepancies
  let confirmationToken: string | null = null
  if (preview.count > 0) {
    confirmationToken = await generateReconciliationToken({
      periodHours,
      discrepancies: preview.count,
      adminUserId,
    })
  }

  return c.json({
    periodHours,
    ...preview,
    confirmationToken,
    confirmationExpiresIn: confirmationToken ? '5 minutes' : null,
    warning: preview.count > 0
      ? `Found ${preview.count} discrepancies. Use the confirmationToken to run autoFix.`
      : 'No discrepancies found.',
  })
})

/**
 * POST /admin/reconciliation/run
 * Manually trigger reconciliation
 * Requires: super_admin
 * If autoFix=true, requires a valid confirmationToken from /preview
 */
system.post('/reconciliation/run', adminSensitiveRateLimit, requireRole('super_admin'), async (c) => {
  const body = await c.req.json().catch(() => ({}))
  const periodHours = body.periodHours || 48
  const autoFix = body.autoFix === true
  const confirmationToken = body.confirmationToken

  // If autoFix is requested, require a valid confirmation token
  if (autoFix) {
    const adminUserId = c.get('adminUserId')
    if (!adminUserId) {
      return c.json({
        error: 'Session authentication required for autoFix. API keys cannot perform autoFix.'
      }, 401)
    }

    if (!confirmationToken) {
      return c.json({
        error: 'autoFix requires a confirmationToken. Call /reconciliation/preview first to get a token.'
      }, 400)
    }

    const tokenResult = await validateReconciliationToken(confirmationToken, adminUserId)
    if (!tokenResult.valid) {
      return c.json({ error: tokenResult.error }, 400)
    }

    // Log the autoFix action
    await logAdminAction(c, 'Reconciliation autoFix', {
      periodHours: tokenResult.periodHours,
      discrepancies: tokenResult.discrepancies,
    })
  }

  const acquired = await acquireReconciliationLock()
  if (!acquired) {
    return c.json({ error: 'Reconciliation already in progress' }, 409)
  }

  try {
    const result = await reconcilePaystackTransactions({
      periodHours,
      autoFix,
      alertOnDiscrepancy: true,
    })

    return c.json({
      success: true,
      ...result,
    })
  } finally {
    await releaseReconciliationLock()
  }
})

/**
 * POST /admin/reconciliation/stripe
 * Manually trigger Stripe reconciliation
 * Requires: super_admin
 */
system.post('/reconciliation/stripe', adminSensitiveRateLimit, requireRole('super_admin'), async (c) => {
  const acquired = await acquireReconciliationLock()
  if (!acquired) {
    return c.json({ error: 'Reconciliation already in progress' }, 409)
  }

  const limit = parseInt(c.req.query('limit') || '100')
  console.log(`[reconciliation] Starting Stripe sync (limit: ${limit})`)

  try {
    const events = await stripe.events.list({
      type: 'invoice.paid',
      limit,
    })

    let processed = 0

    for (const event of events.data) {
      await handleInvoicePaid(event)
      processed++
    }

    return c.json({
      success: true,
      scanned: events.data.length,
      processed,
      message: 'Stripe events replayed successfully. Check logs for details.'
    })
  } catch (err: any) {
    console.error('[reconciliation] Stripe sync failed:', err)
    return c.json({ error: 'Reconciliation failed' }, 500)
  } finally {
    await releaseReconciliationLock()
  }
})

// ============================================
// ACTIVITY FEED
// ============================================

/**
 * GET /admin/activity
 * List admin activities
 */
system.get('/activity', async (c) => {
  const query = z.object({
    page: z.coerce.number().default(1),
    limit: z.coerce.number().min(1).max(200).default(100),
    type: z.string().optional()
  }).parse(c.req.query())

  const skip = (query.page - 1) * query.limit
  const where: any = query.type ? { type: query.type } : {}

  const [activities, totalCount] = await Promise.all([
    db.activity.findMany({
      where,
      skip,
      take: query.limit,
      orderBy: { createdAt: 'desc' },
      include: { user: { select: { email: true, profile: { select: { username: true } } } } }
    }),
    db.activity.count({ where })
  ])

  function getActivityMessage(type: string, payload: any): string {
    switch (type) {
      case 'admin_block': return `Blocked user: ${payload?.reason || 'No reason provided'}`
      case 'admin_unblock': return `Unblocked user`
      case 'admin_refund': return `Issued refund: ${payload?.reason || 'No reason provided'}`
      case 'admin_subscription_paused': return `Paused subscription`
      case 'admin_subscription_resumed': return `Resumed subscription`
      case 'admin_payout_triggered': return `Triggered manual payout`
      case 'admin_payouts_disabled': return `Disabled payouts: ${payload?.reason || ''}`
      case 'admin_payouts_enabled': return `Enabled payouts`
      case 'admin_block_subscriber': return `Blocked subscriber: ${payload?.reason || ''}`
      case 'admin_unblock_subscriber': return `Unblocked subscriber: ${payload?.unblockReason || ''}`
      default: return type.replace(/_/g, ' ').replace(/^admin /, '')
    }
  }

  return c.json({
    activities: activities.map(a => {
      const payload = a.payload as Record<string, any> | null
      return {
        id: a.id,
        type: a.type,
        message: getActivityMessage(a.type, payload),
        adminEmail: payload?.adminEmail || 'System', // Use admin email from payload, not target user
        targetUserId: a.userId,
        targetUserEmail: a.user.email,
        metadata: payload,
        createdAt: a.createdAt
      }
    }),
    total: totalCount,
    page: query.page,
    totalPages: Math.ceil(totalCount / query.limit)
  })
})

// ============================================
// SYSTEM LOGS
// ============================================

/**
 * GET /admin/logs
 * List system logs
 */
system.get('/logs', async (c) => {
  const query = z.object({
    type: z.string().optional(),
    level: z.enum(['info', 'warning', 'error']).optional(),
    userId: z.string().optional(),
    page: z.coerce.number().default(1),
    limit: z.coerce.number().min(1).max(200).default(100)
  }).parse(c.req.query())

  const skip = (query.page - 1) * query.limit
  const where: any = {}

  if (query.type) where.type = query.type
  if (query.level) where.level = query.level
  if (query.userId) where.userId = query.userId

  const [logs, total] = await Promise.all([
    db.systemLog.findMany({
      where,
      skip,
      take: query.limit,
      orderBy: { createdAt: 'desc' }
    }),
    db.systemLog.count({ where })
  ])

  return c.json({
    logs: logs.map(l => ({
      id: l.id,
      type: l.type,
      level: l.level,
      userId: l.userId,
      entityType: l.entityType,
      entityId: l.entityId,
      message: l.message,
      metadata: l.metadata,
      errorCode: l.errorCode,
      errorMessage: l.errorMessage,
      createdAt: l.createdAt
    })),
    total,
    page: query.page,
    totalPages: Math.ceil(total / query.limit)
  })
})

/**
 * GET /admin/logs/stats
 * Log statistics
 */
system.get('/logs/stats', async (c) => {
  const { start: last24h } = lastNDays(1)
  const { start: last7d } = lastNDays(7)

  const [emailsSent24h, emailsFailed24h, remindersSent24h, errors24h, errorsByType] = await Promise.all([
    db.systemLog.count({ where: { type: 'email_sent', createdAt: { gte: last24h } } }),
    db.systemLog.count({ where: { type: 'email_failed', createdAt: { gte: last24h } } }),
    db.systemLog.count({ where: { type: 'reminder_sent', createdAt: { gte: last24h } } }),
    db.systemLog.count({ where: { level: 'error', createdAt: { gte: last24h } } }),
    db.systemLog.groupBy({
      by: ['type'],
      where: { level: 'error', createdAt: { gte: last7d } },
      _count: true
    })
  ])

  return c.json({
    last24h: {
      emailsSent: emailsSent24h,
      emailsFailed: emailsFailed24h,
      remindersSent: remindersSent24h,
      totalErrors: errors24h
    },
    errorsByType: errorsByType.map(e => ({ type: e.type, count: e._count }))
  })
})

// ============================================
// REMINDERS
// ============================================

/**
 * GET /admin/reminders
 * List reminders
 */
system.get('/reminders', async (c) => {
  const query = z.object({
    status: z.enum(['scheduled', 'sent', 'failed', 'canceled', 'all']).default('all'),
    type: z.string().optional(),
    page: z.coerce.number().default(1),
    limit: z.coerce.number().min(1).max(200).default(50)
  }).parse(c.req.query())

  const skip = (query.page - 1) * query.limit
  const where: any = {}

  if (query.status !== 'all') where.status = query.status
  if (query.type) where.type = query.type

  const [reminders, total] = await Promise.all([
    db.reminder.findMany({
      where,
      skip,
      take: query.limit,
      orderBy: { scheduledFor: 'desc' }
    }),
    db.reminder.count({ where })
  ])

  return c.json({
    reminders: reminders.map(r => ({
      id: r.id,
      userId: r.userId,
      entityType: r.entityType,
      entityId: r.entityId,
      type: r.type,
      channel: r.channel,
      status: r.status,
      scheduledFor: r.scheduledFor,
      sentAt: r.sentAt,
      errorMessage: r.errorMessage,
      retryCount: r.retryCount,
      createdAt: r.createdAt
    })),
    total,
    page: query.page,
    totalPages: Math.ceil(total / query.limit)
  })
})

/**
 * GET /admin/reminders/stats
 * Reminder statistics
 */
system.get('/reminders/stats', async (c) => {
  const startOfDay = todayStart()
  const next24h = new Date(Date.now() + 24 * 60 * 60 * 1000)

  const [scheduled, sentToday, failedToday, upcoming] = await Promise.all([
    db.reminder.count({ where: { status: 'scheduled' } }),
    db.reminder.count({ where: { status: 'sent', sentAt: { gte: startOfDay } } }),
    db.reminder.count({ where: { status: 'failed' } }),
    db.reminder.count({ where: { status: 'scheduled', scheduledFor: { lte: next24h } } })
  ])

  return c.json({
    scheduled,
    sentToday,
    failed: failedToday,
    upcomingNext24h: upcoming
  })
})

// ============================================
// EMAILS
// ============================================

/**
 * GET /admin/emails
 * List email logs
 */
system.get('/emails', async (c) => {
  const query = z.object({
    status: z.enum(['sent', 'failed', 'all']).default('all'),
    template: z.string().optional(),
    page: z.coerce.number().default(1),
    limit: z.coerce.number().min(1).max(200).default(100)
  }).parse(c.req.query())

  const skip = (query.page - 1) * query.limit
  const where: any = {}

  if (query.status === 'sent') where.type = 'email_sent'
  else if (query.status === 'failed') where.type = 'email_failed'
  else where.type = { in: ['email_sent', 'email_failed'] }

  if (query.template) {
    where.metadata = { path: ['template'], equals: query.template }
  }

  const [logs, total] = await Promise.all([
    db.systemLog.findMany({
      where,
      skip,
      take: query.limit,
      orderBy: { createdAt: 'desc' }
    }),
    db.systemLog.count({ where })
  ])

  return c.json({
    emails: logs.map(l => {
      const meta = l.metadata as any || {}
      return {
        id: l.id,
        status: l.type === 'email_sent' ? 'sent' : 'failed',
        to: meta.to,
        subject: meta.subject,
        template: meta.template,
        messageId: meta.messageId,
        error: l.errorMessage,
        userId: l.userId,
        createdAt: l.createdAt
      }
    }),
    total,
    page: query.page,
    totalPages: Math.ceil(total / query.limit)
  })
})

// ============================================
// DATA MIGRATION & AUDIT
// ============================================

/**
 * GET /admin/migration/cross-border-profiles
 * Find legacy cross-border profiles with incorrect currency (not USD)
 *
 * Cross-border countries (NG, GH, KE, ZA) MUST use USD for pricing.
 * This endpoint identifies profiles that were created before this
 * enforcement was added and may need data migration.
 */
system.get('/migration/cross-border-profiles', async (c) => {
  // All countries with * on Stripe pricing = cross-border only
  const crossBorderCountries = ['NG', 'GH', 'KE', 'ZA']

  const profiles = await db.profile.findMany({
    where: {
      countryCode: { in: crossBorderCountries },
      currency: { not: 'USD' },
    },
    select: {
      id: true,
      userId: true,
      username: true,
      displayName: true,
      countryCode: true,
      currency: true,
      singleAmount: true,
      tiers: true,
      pricingModel: true,
      createdAt: true,
      user: {
        select: { email: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })

  // Count active subscriptions for these profiles
  const profileUserIds = profiles.map(p => p.userId)
  const activeSubscriptionCounts = await db.subscription.groupBy({
    by: ['creatorId'],
    where: {
      creatorId: { in: profileUserIds },
      status: 'active',
    },
    _count: true,
  })

  const subscriptionMap = new Map(
    activeSubscriptionCounts.map(s => [s.creatorId, s._count])
  )

  return c.json({
    count: profiles.length,
    warning: profiles.length > 0
      ? 'These profiles are in cross-border countries but not using USD. They may experience pricing bugs if not migrated.'
      : null,
    profiles: profiles.map(p => ({
      id: p.id,
      userId: p.userId,
      username: p.username,
      displayName: p.displayName,
      email: p.user?.email || 'unknown',
      countryCode: p.countryCode,
      currency: p.currency,
      pricingModel: p.pricingModel,
      singleAmount: p.singleAmount,
      hasTiers: Array.isArray(p.tiers) && (p.tiers as any[]).length > 0,
      activeSubscriptions: subscriptionMap.get(p.userId) || 0,
      createdAt: p.createdAt,
    })),
    migrationRequired: profiles.length > 0,
    instructions: profiles.length > 0
      ? 'To fix: Use POST /admin/migration/cross-border-profiles/:id to migrate each profile to USD.'
      : 'No migration needed.',
  })
})

/**
 * POST /admin/migration/cross-border-profiles/batch
 * Migrate multiple cross-border profiles to USD pricing
 *
 * For bulk migrations with a default price. Use with caution.
 * IMPORTANT: This route MUST be registered BEFORE the :id route
 * to avoid Hono treating "batch" as a profile ID.
 *
 * Requires: super_admin
 */
system.post('/migration/cross-border-profiles/batch', adminSensitiveRateLimit, requireRole('super_admin'), requireFreshSession, async (c) => {
  const body = z.object({
    defaultAmountUsd: z.number().int().min(1).max(100), // Default price in USD (whole dollars only)
    maxProfiles: z.number().int().min(1).max(50).default(10), // Safety limit
    dryRun: z.boolean().default(true), // Preview only by default
    notifyCreators: z.boolean().default(true),
  }).parse(await c.req.json())
  // Note: All migrated profiles get pricingModel='single' and tiers cleared.

  const crossBorderCountries = ['NG', 'GH', 'KE', 'ZA']

  // Find profiles needing migration
  const profiles = await db.profile.findMany({
    where: {
      countryCode: { in: crossBorderCountries },
      currency: { not: 'USD' },
    },
    take: body.maxProfiles,
    include: {
      user: { select: { id: true, email: true } },
    },
  })

  if (profiles.length === 0) {
    return c.json({
      success: true,
      message: 'No profiles need migration.',
      migrated: 0,
    })
  }

  if (body.dryRun) {
    return c.json({
      dryRun: true,
      wouldMigrate: profiles.length,
      profiles: profiles.map(p => ({
        id: p.id,
        username: p.username,
        email: p.user?.email || 'unknown',
        currentCurrency: p.currency,
        currentAmount: p.singleAmount,
        newCurrency: 'USD',
        newAmountCents: body.defaultAmountUsd * 100,
      })),
      message: `Would migrate ${profiles.length} profiles to USD at $${body.defaultAmountUsd}/month. Set dryRun: false to execute.`,
    })
  }

  // Execute migration
  const newAmountCents = body.defaultAmountUsd * 100
  const results: any[] = []

  for (const profile of profiles) {
    const previousCurrency = profile.currency
    const previousAmount = profile.singleAmount

    await db.profile.update({
      where: { id: profile.id },
      data: {
        currency: 'USD',
        singleAmount: newAmountCents,
        pricingModel: 'single',  // Force single pricing model
        tiers: Prisma.JsonNull,  // Always clear tiers
      },
    })

    results.push({
      id: profile.id,
      username: profile.username,
      previousCurrency,
      newCurrency: 'USD',
    })

    // Log each migration
    await logAdminAction(c, 'cross_border_profile_migrated_batch', {
      profileId: profile.id,
      userId: profile.userId,
      username: profile.username,
      previousCurrency,
      previousAmount,
      previousPricingModel: profile.pricingModel,
      newCurrency: 'USD',
      newAmountCents,
      newPricingModel: 'single',
      batchMigration: true,
    })

    // Send notification email if requested
    if (body.notifyCreators && profile.user?.email) {
      const countryName = profile.countryCode === 'NG' ? 'Nigeria' : profile.countryCode === 'GH' ? 'Ghana' : 'Kenya'
      const creatorName = profile.displayName || profile.username || 'there'
      _sendEmail({
        from: env.EMAIL_FROM,
        to: profile.user.email,
        subject: 'Important: Your NatePay pricing has been updated',
        text: `Hi ${creatorName},\n\nYour NatePay account has been updated to use USD pricing, which is required for creators in ${countryName}.\n\nWhat changed:\n- Your subscription price is now $${body.defaultAmountUsd}/month\n- Subscribers will be charged in USD\n- Your payouts will automatically convert to your local currency\n\nIf you'd like to adjust your pricing, you can do so in your NatePay dashboard.\n\nQuestions? Reply to this email and we'll help.\n\n— The NatePay Team`,
        html: `
          <p>Hi ${creatorName},</p>
          <p>Your NatePay account has been updated to use USD pricing, which is required for creators in ${countryName}.</p>
          <p><strong>What changed:</strong></p>
          <ul>
            <li>Your subscription price is now $${body.defaultAmountUsd}/month</li>
            <li>Subscribers will be charged in USD</li>
            <li>Your payouts will automatically convert to your local currency</li>
          </ul>
          <p>If you'd like to adjust your pricing, you can do so in your NatePay dashboard.</p>
          <p>Questions? Reply to this email and we'll help.</p>
          <p>— The NatePay Team</p>
        `,
      }).catch((err: Error) => {
        console.error(`[migration] Failed to send notification email to ${profile.user?.email}:`, err)
      })
    }
  }

  return c.json({
    success: true,
    migrated: results.length,
    results,
    message: `Migrated ${results.length} profiles to USD at $${body.defaultAmountUsd}/month.`,
  })
})

/**
 * POST /admin/migration/cross-border-profiles/:id
 * Migrate a single cross-border profile to USD pricing
 *
 * This fixes legacy profiles that were created with local currency
 * (NGN, GHS, KES) before USD enforcement was added.
 *
 * Requires: super_admin
 */
system.post('/migration/cross-border-profiles/:id', adminSensitiveRateLimit, requireRole('super_admin'), requireFreshSession, async (c) => {
  const { id } = c.req.param()
  const body = z.object({
    newAmountUsd: z.number().int().min(1).max(10000), // New price in USD (whole dollars only)
    notifyCreator: z.boolean().default(true),          // Send email notification
  }).parse(await c.req.json())
  // Note: Tiers are ALWAYS cleared during migration. Keeping tiers with local
  // currency amounts would create wildly incorrect USD prices (e.g., ₦5000 → $5000).
  // pricingModel is also set to 'single' to ensure UI consistency.

  // Find the profile
  const profile = await db.profile.findUnique({
    where: { id },
    include: {
      user: { select: { id: true, email: true } },
    },
  })

  if (!profile) {
    return c.json({ error: 'Profile not found' }, 404)
  }

  // Validate it's actually a cross-border profile with wrong currency
  // Uses shared config instead of hardcoded list
  if (!isStripeCrossBorder(profile.countryCode)) {
    return c.json({
      error: `Profile is not in a cross-border country (${profile.countryCode}). No migration needed.`,
    }, 400)
  }

  if (profile.currency === 'USD') {
    return c.json({
      error: 'Profile already uses USD. No migration needed.',
    }, 400)
  }

  // Store old values for audit log
  const previousCurrency = profile.currency
  const previousAmount = profile.singleAmount
  const previousTiers = profile.tiers

  // Convert new amount to cents
  const newAmountCents = body.newAmountUsd * 100

  // Update the profile
  // Always clear tiers and set pricingModel to 'single' to avoid currency mismatch
  const updated = await db.profile.update({
    where: { id },
    data: {
      currency: 'USD',
      singleAmount: newAmountCents,
      pricingModel: 'single',  // Force single pricing model
      tiers: Prisma.JsonNull,  // Always clear tiers
    },
  })

  // Log the migration action
  await logAdminAction(c, 'cross_border_profile_migrated', {
    profileId: id,
    userId: profile.userId,
    username: profile.username,
    previousCurrency,
    previousAmount,
    previousTiers: Array.isArray(previousTiers) ? (previousTiers as any[]).length : 0,
    previousPricingModel: profile.pricingModel,
    newCurrency: 'USD',
    newAmountCents,
    newPricingModel: 'single',
    tiersCleared: true,
  })

  // Optionally notify the creator
  if (body.notifyCreator && profile.user.email) {
    const countryName = profile.countryCode === 'NG' ? 'Nigeria' : profile.countryCode === 'GH' ? 'Ghana' : 'Kenya'
    const creatorName = profile.displayName || profile.username || 'there'
    // Send notification email (non-blocking)
    _sendEmail({
      from: env.EMAIL_FROM,
      to: profile.user.email,
      subject: 'Important: Your NatePay pricing has been updated',
      text: `Hi ${creatorName},\n\nYour NatePay account has been updated to use USD pricing, which is required for creators in ${countryName}.\n\nWhat changed:\n- Your subscription price is now $${body.newAmountUsd}/month\n- Subscribers will be charged in USD\n- Your payouts will automatically convert to your local currency\n\nIf you'd like to adjust your pricing, you can do so in your NatePay dashboard.\n\nQuestions? Reply to this email and we'll help.\n\n— The NatePay Team`,
      html: `
        <p>Hi ${creatorName},</p>
        <p>Your NatePay account has been updated to use USD pricing, which is required for creators in ${countryName}.</p>
        <p><strong>What changed:</strong></p>
        <ul>
          <li>Your subscription price is now $${body.newAmountUsd}/month</li>
          <li>Subscribers will be charged in USD</li>
          <li>Your payouts will automatically convert to your local currency</li>
        </ul>
        <p>If you'd like to adjust your pricing, you can do so in your NatePay dashboard.</p>
        <p>Questions? Reply to this email and we'll help.</p>
        <p>— The NatePay Team</p>
      `,
    }).catch((err: Error) => {
      console.error('[migration] Failed to send notification email:', err)
    })
  }

  return c.json({
    success: true,
    profile: {
      id: updated.id,
      username: updated.username,
      displayName: updated.displayName,
      currency: updated.currency,
      singleAmount: updated.singleAmount,
      previousCurrency,
      previousAmount,
    },
    message: `Profile migrated to USD. New price: $${body.newAmountUsd}/month.`,
  })
})

// ============================================
// INVOICES
// ============================================

/**
 * GET /admin/invoices
 * List invoices (requests with due dates)
 */
system.get('/invoices', async (c) => {
  const query = z.object({
    status: z.enum(['draft', 'sent', 'pending_payment', 'paid', 'declined', 'expired', 'all']).default('all'),
    page: z.coerce.number().default(1),
    limit: z.coerce.number().min(1).max(200).default(50)
  }).parse(c.req.query())

  const skip = (query.page - 1) * query.limit
  const where: any = { dueDate: { not: null } }

  if (query.status !== 'all') where.status = query.status === 'paid' ? 'accepted' : query.status

  const [requests, total] = await Promise.all([
    db.request.findMany({
      where,
      skip,
      take: query.limit,
      orderBy: { createdAt: 'desc' },
      include: {
        creator: { select: { email: true, profile: { select: { username: true, displayName: true } } } }
      }
    }),
    db.request.count({ where })
  ])

  return c.json({
    invoices: requests.map(r => ({
      id: r.id,
      creator: {
        id: r.creatorId,
        email: r.creator.email,
        username: r.creator.profile?.username || null,
        displayName: r.creator.profile?.displayName || null,
      },
      recipientName: r.recipientName,
      recipientEmail: r.recipientEmail,
      recipientPhone: r.recipientPhone,
      amountCents: r.amountCents,
      currency: r.currency,
      status: r.status === 'accepted' ? 'paid' : r.status,
      dueDate: r.dueDate,
      sentAt: r.sentAt,
      respondedAt: r.respondedAt,
      createdAt: r.createdAt
    })),
    total,
    page: query.page,
    totalPages: Math.ceil(total / query.limit)
  })
})

export default system
